package watcher
//go:build linux



















































































































































}	return strings.Split(string(data), "\n"), nil	}		return nil, err	if err != nil {	data, err := os.ReadFile("/var/log/wtmp")	// Not used in the main watch loop, but useful for testing	// This is a helper function that can be used to get recent loginsfunc GetRecentLogins() ([]string, error) {// GetRecentLogins returns recent login records using 'last' command}	return nil	<-ctx.Done()	}()		}			}				}					}						return					case <-ctx.Done():					case events <- *event:					select {				if event != nil {				}					}						OS:        "linux",						Timestamp: time.Now(),						Terminal:  matches[1],						Hostname:  w.hostname,						Username:  matches[2],					event = &notifier.LoginEvent{				if matches := ttyPattern.FindStringSubmatch(line); matches != nil {				// Check TTY login				}					}						}							OS:        "linux",							Timestamp: time.Now(),							Terminal:  service,							Hostname:  w.hostname,							Username:  user,						event = &notifier.LoginEvent{					if service != "sshd" {					// Avoid duplicate with SSH pattern					user := matches[2]					service := matches[1]				if matches := pamPattern.FindStringSubmatch(line); matches != nil {				// Check PAM session				}					}						OS:        "linux",						Timestamp: time.Now(),						Terminal:  "ssh",						IP:        matches[2],						Hostname:  w.hostname,						Username:  matches[1],					event = &notifier.LoginEvent{				if matches := sshPattern.FindStringSubmatch(line); matches != nil {				// Check SSH login				var event *notifier.LoginEvent				}					continue					time.Sleep(100 * time.Millisecond)					// No new lines, wait a bit				if err != nil {				line, err := reader.ReadString('\n')			default:				return			case <-ctx.Done():			select {		for {	go func() {	reader := bufio.NewReader(file)	ttyPattern := regexp.MustCompile(`LOGIN ON\s+(\w+)\s+BY\s+(\w+)`)	// TTY login: "LOGIN ON ttyX BY user"	pamPattern := regexp.MustCompile(`pam_unix\((\w+):session\):\s+session opened for user\s+(\w+)`)	// PAM session opened: "pam_unix(sshd:session): session opened for user xxx"	sshPattern := regexp.MustCompile(`sshd\[\d+\]:\s+Accepted\s+\w+\s+for\s+(\w+)\s+from\s+([\d\.]+)\s+port\s+\d+`)	// SSH login: "Accepted publickey for user from IP port ..."	// SSH login: "Accepted password for user from IP port ..."	// Patterns to detect login events	}		return fmt.Errorf("linux: failed to seek to end: %w", err)	if _, err := file.Seek(0, 2); err != nil {	// Seek to end of file to only watch new entries	defer file.Close()	}		return fmt.Errorf("linux: failed to open log file %s: %w", w.logFile, err)	if err != nil {	file, err := os.Open(w.logFile)func (w *LinuxWatcher) Watch(ctx context.Context, events chan<- notifier.LoginEvent) error {// Watch monitors Linux auth logs for login events}	return "linux"func (w *LinuxWatcher) Name() string {// Name returns the watcher name}	}, nil		logFile:  logFile,		hostname: hostname,	return &LinuxWatcher{	}		logFile = "/var/log/secure" // RHEL/CentOS	if _, err := os.Stat(logFile); os.IsNotExist(err) {	logFile := "/var/log/auth.log" // Debian/Ubuntu	// Determine which log file to watch	}		hostname = "unknown"	if err != nil {	hostname, err := os.Hostname()func newPlatformWatcher() (Watcher, error) {}	logFile  string	hostname stringtype LinuxWatcher struct {// LinuxWatcher watches for login events on Linux)	"github.com/xsddz/whozere/internal/notifier"	"time"	"strings"	"regexp"	"os"	"fmt"	"context"	"bufio"import (package watcher