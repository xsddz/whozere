package watcher
//go:build windows










































































































































}	return nil	<-ctx.Done()	}()		}			}				}					}						return					case <-ctx.Done():					case events <- event:					select {					}						OS:        "windows",						Timestamp: time.Now(),						Terminal:  logonType,						IP:        ip,						Hostname:  w.hostname,						Username:  username,					event := notifier.LoginEvent{					}						}							ip = ""						if ip == "-" {						ip = matches[1]					if matches := ipPattern.FindStringSubmatch(msg); matches != nil {					var ip string					// Extract IP if available					}						}							logonType = "cachedinteractive"						case "11":							logonType = "remoteinteractive"						case "10":							logonType = "unlock"						case "7":							logonType = "service"						case "5":							logonType = "batch"						case "4":							logonType = "network"						case "3":							logonType = "interactive"						case "2":						switch matches[1] {					if matches := logonTypePattern.FindStringSubmatch(msg); matches != nil {					logonType := "unknown"					// Extract logon type					}						continue					if username == "" || username == "-" || username == "SYSTEM" || strings.HasSuffix(username, "$") {					// Skip system accounts					}						username = matches[1]					if matches := userPattern.FindStringSubmatch(msg); matches != nil {					var username string					// Extract username					}						continue					if msg == "" {				for _, msg := range messages {				messages := strings.Split(string(output), "\r\n\r\n")				}					continue					// No events or access denied, continue				if err != nil {				output, err := cmd.Output()				cmd := exec.CommandContext(ctx, "powershell", "-Command", psCmd)				psCmd := fmt.Sprintf(`Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624; StartTime='%s'} -ErrorAction SilentlyContinue | ForEach-Object { $_.Message }`, startTime)				// PowerShell command to get recent login events				lastCheck = time.Now()				startTime := lastCheck.Format("2006-01-02T15:04:05")				// Query for new login events since last check			case <-ticker.C:				return			case <-ctx.Done():			select {		for {	go func() {	logonTypePattern := regexp.MustCompile(`Logon Type:\s+(\d+)`)	ipPattern := regexp.MustCompile(`Source Network Address:\s+(\S+)`)	userPattern := regexp.MustCompile(`Account Name:\s+(\S+)`)	// Pattern to extract user info from event message	lastCheck := time.Now()	defer ticker.Stop()	ticker := time.NewTicker(5 * time.Second)	// We use Get-WinEvent in a loop to check for new events	// Event ID 4624 = Successful logon	// Use PowerShell to monitor Windows Security Event Logfunc (w *WindowsWatcher) Watch(ctx context.Context, events chan<- notifier.LoginEvent) error {// Watch monitors Windows Event Log for login events}	return "windows"func (w *WindowsWatcher) Name() string {// Name returns the watcher name}	return &WindowsWatcher{hostname: hostname}, nil	}		hostname = "unknown"	if err != nil {	hostname, err := os.Hostname()func newPlatformWatcher() (Watcher, error) {}	hostname stringtype WindowsWatcher struct {// WindowsWatcher watches for login events on Windows)	"github.com/xsddz/whozere/internal/notifier"	"time"	"strings"	"regexp"	"os/exec"	"os"	"fmt"	"context"import (package watcher